import "util.scrypt";

contract Counter {
	public function increment(bytes sighashPreimage, int amount) {
        TxAdvanced tx = new TxAdvanced();
		require(tx.validate(sighashPreimage, 
							PrivKey(b'ea401e7cedf9c428fbf9b92b75c90dfdd354394e58195d58e82bf79a8de31d62'),	// in little endian
							PubKey(b'02773aca113a3217b67a95d5b78b69bb6386ed443ea5decf0ba92c00d179291921'),
							0xa2103f96554aba49bbf581738d3b5a38c5a44b6238ffb54cfcca65b8c87ddc08,				// inverse of k
							0x00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60,			// r
							b'00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60',			// r in big endian
							b'c1'));	// SIGHASH_ALL | SIGHASH_ANYONECANPAY | SIGHASH_FORKID

        int len = length(sighashPreimage);
		bytes hashOutputs = sighashPreimage[len - 40 : len - 8];
		// scriptCode is just scriptPubKey if there is no CODESEPARATOR in the latter
		bytes scriptCode = Util.readVarint(sighashPreimage[104:]);
		int scriptLen = length(scriptCode);
		// last byte contains the state, i.e., counter
		int counter = unpack(scriptCode[scriptLen - 1 :]);
		// increment counter
		bytes scriptCode_ = scriptCode[: scriptLen - 1] ++ num2bin(counter + 1, 1);
		// output: amount + scriptlen + script
		Sha256 hashOutputs_ = hash256(num2bin(amount, 8) ++ Util.writeVarint(scriptCode_));
		// ensure output is expected: amount is same with specified
		// also output script is the same with scriptCode except counter incremented
		require(hashOutputs == hashOutputs_);
    }
}